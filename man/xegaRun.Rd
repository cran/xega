% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xegaRun.R
\name{xegaRun}
\alias{xegaRun}
\title{Run an evolutionary or genetic algorithm for a problem environment 
which contains a function to optimize.}
\usage{
xegaRun(
  penv,
  grammar = NULL,
  max = TRUE,
  algorithm = "sga",
  popsize = 100,
  generations = 20,
  crossrate = 0.2,
  mutrate = 1,
  elitist = TRUE,
  replay = 0,
  maxdepth = 7,
  maxtrials = 5,
  codons = 25,
  codonBits = 0,
  codonPrecision = "LCM",
  maxPBias = 0.01,
  evalmethod = "EvalGeneU",
  reportEvalErrors = TRUE,
  genemap = "Bin2Dec",
  crossrate2 = 0.3,
  ivcrossrate = "Const",
  crossover = "Cross2Gene",
  uCrossSwap = 0.2,
  mincrossdepth = 1,
  maxcrossdepth = 7,
  ivmutrate = "Const",
  mutrate2 = 1,
  bitmutrate = 0.005,
  bitmutrate2 = 0.01,
  maxmutdepth = 3,
  minmutinsertiondepth = 1,
  maxmutinsertiondepth = 7,
  lambda = 0.05,
  max2opt = 100,
  scalefactor1 = 0.9,
  scalefactor2 = 0.3,
  scalefactor = "Const",
  cutoffFit = 0.5,
  mutation = "MutateGene",
  replication = "Kid2",
  offset = 1,
  eps = 0.01,
  tournamentSize = 2,
  selectionBias = 1.5,
  maxTSR = 1.5,
  selection = "SUS",
  mateselection = "SUS",
  selectionContinuation = TRUE,
  scaling = "NoScaling",
  scalingThreshold = 0,
  scalingExp = 1,
  scalingExp2 = 1,
  rdmWeight = 1,
  drMax = 2,
  drMin = 0.5,
  dispersionMeasure = "var",
  scalingDelay = 1,
  accept = "All",
  alpha = 0.99,
  beta = 2,
  cooling = "ExponentialMultiplicative",
  coolingPower = 1,
  temp0 = 40,
  tempN = 0.01,
  verbose = 1,
  logevals = FALSE,
  allsolutions = FALSE,
  early = FALSE,
  terminationEps = 0.01,
  cores = NA,
  executionModel = "Sequential",
  uParApply = NULL,
  Cluster = NULL,
  profile = FALSE,
  batch = FALSE,
  path = ""
)
}
\arguments{
\item{penv}{Problem environment.}

\item{grammar}{A compiled grammar object. Default: NULL.
Example: \code{compileBNF(booleanGrammar())}}

\item{max}{If \code{TRUE} then Maximize! Default: TRUE.
Used in functions \code{EvalGeneDet}, \code{EvalGeneStoch},
\code{EvalGeneU}, and \code{EvalGeneR} 
of package \code{xegaSelectGene}.}

\item{algorithm}{Specifies the algorithm class dependend 
on gene representation:
\itemize{
\item "sga": Binary representation (Default).
\item "sgde": Real representation. 
       E.g. Differential evolution.
\item "sgperm": Permutation representation.
\item "sge": Binary representation. 
             Grammatical evolution.    
             (Not yet variable length.)
\item "sgp": Derivation tree representation. 
             Grammar Based Genetic Programming.
}}

\item{popsize}{Population size. Default: 100.}

\item{generations}{Number of generations. Default: 20.}

\item{crossrate}{Probability of applying crossover operator. Default: 0.20.
(Global parameter)}

\item{mutrate}{Probability of applying mutation operator. Default: 1.0.
(Global parameter)}

\item{elitist}{Boolean. If \code{TRUE}, 
then keep best solution in population.
Default: \code{TRUE}.}

\item{replay}{Integer. If \code{replay>0} then use \code{replay} 
    as seed of random number generator and  
    store it for exact repetition of run.
Default: 0.}

\item{maxdepth}{The maximal depth of a derivation tree. Default: 7. (\code{"sgp"}).}

\item{maxtrials}{Maximal number of trials of finding subtrees with same root symbol.
Default: 5. (\code{sgp}).}

\item{codons}{The maximal number of codons of derivations on a gene. 
Default: 25. (\code{"sge"}).}

\item{codonBits}{The number of bits of a codon.
Default: 0. (\code{"sge"}).}

\item{codonPrecision}{Specify the method to set the number of bits of a
          codon (\code{"sge"}):  
          \itemize{
          \item "Min": Sufficient to code the maximal number 
                       of choices of production rules for 
                       a non-terminal.
          \item "LCM": Contains the least common multiple 
                       of the prime factors of the number of 
                       choices of production rules for all 
                       non-terminals.
          \item "MaxPBias": The computed precision guarantees
                       that the choice rule bias for a non-terminal
                       is below \code{maxPBias}. 
          }
Argument of function factory 
\code{xegaGePrecisionFactory} in package \code{xegaGeGene}.}

\item{maxPBias}{The threshold of the choice rule bias. 
Default: \code{0.01}. (\code{sge}").}

\item{evalmethod}{Specifies the method of function evaluation:
    \itemize{ 
    \item  "EvalGeneU": The function is always evaluated. (Default)
    \item  "EvalGeneR": The function is always evaluated. 
                        Repairs of the gene by the decoder are 
                        possible.
    \item  "Deterministic": The function is evaluated only once.
    \item  "Stochastic": The expected function value and its 
                            variance are incrementally updated.
}
    Argument of function factory 
    \code{EvalGeneFactory} in package xegaSelectGene.}

\item{reportEvalErrors}{Report errors in the evaluation 
of fitness functions. Default: TRUE.}

\item{genemap}{Gene map for decoding. Default: "Bin2Dec".
                   The default value works only for algorithm "sga".
                   Used as \code{method} argument of the function factory
                   \code{sgXGeneMapFactory} of package \code{xega}.

                   Available available options determined by 
                   \code{algorithm}:
                   \itemize{
                   \item "sga": Binary representation (Default).
                   \itemize{
                   \item "Bin2Dec": For real parameter vectors. 
                   \item "Gray2Dec": For real parameter vectors.
                   \item "Identity": For 0/1 parameter vectors.
                   \item "Permutation": For permutations.
                   }
                   See the function factory 
                   \code{xegaGaGeneMapFactory} in package \code{xegaGaGene}.
                   \item "sgp": Derivation tree. 
                          Gene map is not used, but must be specified.
                          We use \code{xegaGaGene::xegaGaGeneMapFactory} 
                          with \code{method="Identity"}.
                   \item "sge": Binary representation (Default).
                         How are genes decoded?
                   \itemize{
                   \item "Mod": The modulo rule.
                   \item "Bucket": The bucket rule (with the mLCM). 
                         Problem: Mapping \code{1: 2^k} to \code{1:mLCMG}.
                   }
                   See the function factory 
                   \code{xegaGeGeneMapFactory} in package \code{xegaGeGene}.
                   \item "sgde": Real coded gene.
                          We use \code{xegaDfGene::xegaDfGeneMapFactory} 
                          with \code{method="Identity"}.
                          Function used: \code{xegaDfGene::xegaDfGeneMapIdentity}
                   \item "sgperm": Permutation gene.
                          Gene map is not used, but must be specified.
                          We use \code{xegaDfGene::xegaDfGeneMapFactory} 
                          with \code{method="Identity"}.
                          Function used: \code{xegaDfGene::xegaDfGeneMapIdentity}
                          
                   } # end of genemap}

\item{crossrate2}{Crossover rate for genes with below 
``average'' fitness. 
Probability of applying crossover operator 
for genes with a ``below average'' fitness.
Default: 0.30. 
(Global parameter)}

\item{ivcrossrate}{Specifies the method of determining the crossover rate.
          \itemize{
          \item 
           "Const" Constant crossover rate. 
           The probability of applying the crossover operator
           is constant for the whole run of the algorithm.
           Default: "Const".
           \item "IV" Individually variable crossover rate.
           The crossrate of a gene is determined by the following threshold
           rule: 
           If the fitness of the gene is higher than 
           \code{lF$CutoffFit()*} \code{lF$CBestFitness()} then 
           \code{lF$CrossRate1()} else \code{lF$CrossRate2()}
           is used.
           } 
Argument of function factory 
\code{CrossRateFactory} in package \code{xegaPopulation}.}

\item{crossover}{Crossover method. Default: "CrossGene".
                   The choice of crossover methods depends on the 
                   setting of the argument \code{algorithm}.
                   Used as the \code{method} argument in function factory
                   \code{sgXCrossoverFactory} of package \code{xega}.

                   \itemize{
                   \item \code{algorithm="sga"}:
                   \code{crossover} is  argument of function factory 
                   \code{xegaGaCrossoverFactory} in package \code{xegaGaGene}.
                   \itemize{
                   \item Crossover operators with 1 kid:
                   \itemize{
                   \item "CrossGene"  one-point crossover. 
                   \item "UCrossGene" uniform crossover.
                   \item "UPCrossgene" parameterized uniform crossover.
                         Local parameter: \code{uCrossSwap}.
                   }
                   \item Crossover operators with 2 kids:
                   \itemize{
                   \item "Cross2Gene"  one-point crossover. 
                   \item "UCross2Gene" uniform crossover.
                   \item "UPCross2gene" parameterized uniform crossover.
                         Local parameter: \code{uCrossSwap}.
                   }
                   }
                   \item \code{algorithm="sgp"}:
                   \code{crossover} is  argument of function factory 
                   \code{xegaGpCrossoverFactory} in package \code{xegaGpGene}.
                   \itemize{
                   \item Crossover operators with 1 kid:
                   \itemize{
                   \item "CrossGene"  position based one-point crossover. 
                   }
                   \item Crossover operators with 2 kids:
                   \itemize{
                   \item "Cross2Gene" position based one-point crossover. 
                   }
                   }
                   \item \code{algorithm="sge"}:
                   We use the factory \code{xegaGaCrossoverFactory}.

                   (Adpatation needed for variable-length binary
                   representation.)

                   \item \code{algorithm="sgde"}:
                   \code{crossover} is  argument of function factory 
                   \code{xegaDfCrossoverFactory} in package \code{xegaDfGene}.
                   \itemize{
                   \item Crossover operators with 1 kid:
                   \itemize{
                   \item "CrossGene"  one-point crossover  (of reals)
                   \item "UCrossGene" uniform crossover  (of reals)
                   \item "UPCrossGene" parametrized 
                          uniform crossover  (of reals).
                          Local parameter: \code{uCrossSwap}.
                   }
                   \item Crossover operators with 2 kids: Not implemented.
                   }

                   \item \code{algorithm="sgperm"}:
                   \code{crossover} is  argument of function factory 
                   \code{xegaPermCrossoverFactory} in package \code{xegaPermGene}.
                   \itemize{
                   \item Crossover operators with 1 kid:
                   \itemize{
                   \item "CrossGene"  position based one-point crossover. 
                   }
                   \item Crossover operators with 2 kids:
                   \itemize{
                   \item "Cross2Gene" position based one-point crossover. 
                   }
                   }
                   }}

\item{uCrossSwap}{The fraction of positions swapped in the
parametrized uniform crossover operator.
A local crossover parameter.
Default: 0.2. (\code{"sga"} and \code{"sgde"}). 
Used in packages \code{xegaGaGene} and \code{xegaDfGene}
for functions 
\code{xegaGaUPCross2Gene},
\code{xegaDfUPCross2Gene},
\code{xegaGaUPCrossGene}, and
\code{xegaDfUPCrossGene}.}

\item{mincrossdepth}{minimal depth of exchange nodes (roots of subtrees
swapped by crossover). (\code{"sgp"}).}

\item{maxcrossdepth}{Maximal depth of exchange nodes (roots of subtrees
  swapped by crossover). (\code{"sgp"}).
Used in package \code{xegaGpGene} functions 
 \code{xegaGpCrossGene} and \code{xegaGpCross2Gene}
in package xegaGpGene.}

\item{ivmutrate}{"Const" or "IV" (individually variable). 
Default: "Const".}

\item{mutrate2}{Mutation rate. Default: 1.0.
(Global parameter).}

\item{bitmutrate}{Bit mutation rate. Default: 0.005.
A local mutation parameter. (\code{"sga"} and \code{"sge"}).
 Used in package \code{xegaGaGene} functions 
  \code{MutateGene}
  \code{IVAdaptiveMutateGene}}

\item{bitmutrate2}{Bit mutation rate for genes
   with ``below average'' fitness. Default: 0.01.
A local mutation parameter. (\code{"sga"} and \code{"sge"}).
 Used in package \code{xegaGaGene} functions 
  \code{IVAdaptiveMutateGene}}

\item{maxmutdepth}{Maximal depth of a derivation tree inserted 
by mutation. Default: 3. (\code{"sgp"}).}

\item{minmutinsertiondepth}{Minimal depth at which an insertion tree
is inserted. Default: 1. (\code{"sgp"}).}

\item{maxmutinsertiondepth}{Maximal depth at which an insertion tree
 is inserted. Default: 7. (\code{"sgp"}).
Used in package \code{xegaGpGene} function
 \code{xegaGpMutateGene}.}

\item{lambda}{Decay rate. Default: 0.05.
A local mutation parameter. (\code{"sgperm"}).
 Used in package \code{xegaPermGene} function
  \code{xegaPermMutateGenekInversion}.}

\item{max2opt}{Maximal number of trials to find
an improvement by a random edge exchange 
in a permutation. Default: \code{100}. (\code{"sgperm"}).
 Used in package \code{xegaPermGene} function
  \code{xegaPermMutateGene2Opt}.
and  \code{xegaPermMutateGeneOptLK}.}

\item{scalefactor1}{Scale factor for differential mutation operator (Default: 0.9). (\code{"sgde"}).}

\item{scalefactor2}{Scale factor for differential mutation operator (Default: 0.2). (\code{"sgde"}).}

\item{scalefactor}{Method for setting scale factor (\code{"sgde"}):
\itemize{
\item "Const":  constant scale factor. 
\item "Uniform": a random scale factor in 0.000001 to 1.0.
 }}

\item{cutoffFit}{Cutoff for fitness.      Default: 0.5. (\code{"sga"} and \code{"sge"}).
Used in package \code{xegaGaGene} function
 \code{IVAdaptiveMutateGene}.}

\item{mutation}{Label specifies mutation method
                   dependend on \code{algorithm}. Default: "MutateGene".
                   The (global) probability of calling a mutation method
                   is specified by \code{mutrate} and \code{mutrate2}.
                   Used as \code{method} argument of function factory 
                   \code{sgXMutationFactory} package \code{xega}. 
      
                   \itemize{
                   \item \code{algorithm="sga"}:
                   \code{mutation} is  argument of function factory 
                   \code{xegaGaMutationFactory} in package \code{xegaGaGene}.
                   \itemize{
                   \item "MutateGene": Bitwise mutation. 
                         Local parameter: \code{bitmutrate}.
                         Function used: \code{xegaGaGene::xegaGaMutateGene}.
                   \item "IVM": Invividually variable mutation.
                         Intuitively we know that 
                         bad genes need higher mutation rates.
                         Good genes have a fitness which is 
                         above a threshold fitness. The threshold
                         is determined as a percentage of the 
                         current best fitness in the population.
                         The percentage is set by the parameter 
                         \code{cutoffFit}. 
                         Local parameters: \code{bitmutrate} for good genes.
                         \code{bitmutrate2} for bad genes.
                         \code{bitmutrate2} should be higher then 
                         \code{bitmutrate}.
                   }
                   \item \code{algorithm="sgp"}:
                   \code{mutation} is  argument of function factory 
                   \code{xegaGpMutationFactory} in package \code{xegaGpGene}.

                   \itemize{
                   \item "MutateGene": Random insertion of 
                          a random derivation tree. 
                         Local parameter: \code{maxmutdepth}.
                         Function used: \code{xegaGpGene::xegaGpMutateGene}.
                    }

                   \item \code{algorithm="sge"}:
                   \code{mutation} is  argument of function factory 
                   \code{xegaGaMutationFactory}.
                   Nothing specific to grammatical evolution implemented.

                   \item \code{algorithm="sgde"}:
                   \code{mutation} is  argument of function factory 
                   \code{xegaDfMutationFactory} in package \code{xegaDfGene}.

                   \itemize{
                   \item "MutateGene": Add the scaled difference 
                         of the parameters of two randomly selected
                         to a gene.
                         Local parameters: Choice of function for 
                                     \code{scalefactor} as well as
                                           \code{scalefactor1}  
                                           and \code{scalefactor2}.
                         Function used: \code{xegaDfGene::xegaDfMutateGeneDE}.
                    }

                   \item \code{algorithm="sgperm"}:
                   \code{mutation} is  argument of function factory 
                   \code{xegaPermMutationFactory} in package \code{xegaPermGene}.

       \itemize{
       \item "MutateGene": 
             Function used: \code{xegaPermGene::xegaPermMutateGeneOrderBased}.
       \item "MutateGeneOrderBased": See "MutateGene". 
       \item "MutateGenekInversion": 
             Function used: \code{xegaPermGene::xegaPermMutateGenekInversion}.
       \item "MutateGene2Opt": 
             Function used: \code{xegaPermGene::xegaPermMutateGene2Opt}.
       \item "MutateGenekOptLK": 
             Function used: \code{xegaPermGene::xegaPermMutateGenekOptLK}.
       \item "MutateGeneGreedy": 
             Function used: \code{xegaPermGene::xegaPermMutateGeneGreedy}.
       \item "MutateGeneBestGreedy": 
             Function used: \code{xegaPermGene::xegaPermMutateGeneBestGreedy}.
       \item "MutateGeneMix": 
             Function used: \code{xegaPermGene::xegaPermMutateMix}.
       }
                   }}

\item{replication}{"Kid1" or "Kid2". Default: "Kid1".
                   For algorithms "sga", "sgPerm", "sgp", and "sge":
                   "Kid1" means a crossover operator with one kid,
                   "Kid2" means a crossover operator with two kids.
                    
                    For algorithm "sgde", \code{replication} must be 
                    set to "DE".

                   Used as the \code{method} argument of the 
                   function factory \code{sgXReplicationFactory} 
                   of package \code{xega}.}

\item{offset}{Offset used in proportional selection. Default: 1. 
Used in the following functions of package \code{xegaSelectGene}: 
\code{ScaleFitness},
\code{PropFitOnLn},
\code{PropFit},
\code{PropFitM},
\code{PropFitDiffOnLn},
\code{PropFitDiff},
\code{SUS}.}

\item{eps}{Epsilon in proportional 
fitness difference selection. Default: 0.01.
Used in package \code{xegaSelectGene} function
\code{PropFitDiffM}.}

\item{tournamentSize}{Tournament size. Default: 2. 
Used in package \code{xegaSelectGene} functions
\code{SelectTournament},
\code{SelectSTournament}.}

\item{selectionBias}{(> 1.0). Controls selection pressure for 
Whitley's linear rank selection
with selective pressure. Default: 1.5. Near 1.0: almost
uniform selection.
            Used in package \code{xegaSelectGene} function
            \code{SelectLRSelective},}

\item{maxTSR}{Controls selection pressure for 
         Grefenstette and Baker's linear rank selection 
         method. Should be higher than 1.0 and lower equal 2.0.
         Default: 1.5.
           Used in package \code{xegaSelectGene} function
\code{SelectLinearRankTSR}.}

\item{selection}{Selection method for first parent of crossover. 
Default: "SUS".}

\item{mateselection}{Selection method for second parent of crossover. 
                      Default: "SUS". 

Available selection methods for selection method of a parent:
\itemize{
\item Uniform random selection: "Uniform".
\item Uniform random selection without replacement: "UniformP".
\item Proportional to fitness: 
      "ProportionalOnln" (fastest), "Proportional", "ProportionalM",
\item Proportional to fitness differences: 
      "PropFitDiffOnln" (fastest), "PropfitDiff", "PropfitDiffM",
\item Stochastic universal sampling: "SUS", 
\item Tournament selection: "Duel" (fastest), "Tournament", "STournament",  
\item Rank selection: "LRSelective" (fastest), "LRTSR".
}
                   Argument of function factory 
                   \code{SelectGeneFactory} in package \code{xegaSelectGene}.}

\item{selectionContinuation}{Boolean. If \code{TRUE}, 
precomputes selection indices for next generation once and
transforms selection function to index lookup continuation.
Default: \code{TRUE}.
Used in package \code{xegaPopulation} function \code{xegaNextPopulation}.}

\item{scaling}{Scaling method. Default: "NoScaling".
Available scaling methods: 
\itemize{
\item "NoScaling", 
\item "ConstantScaling" (Static), 
\item "ThresholdScaling" (Dynamic), 
\item "ContinuousScaling" (Dynamic).
}
Argument of function factory 
\code{ScalingFactory} in package \code{xegaSelectGene}.}

\item{scalingThreshold}{Numerical constant. Default: 0.0.
       If  ratio of dispersion measures is in 
       [(1-scalingThreshold), 1+scalingThreshold)], 
       fitness is not scaled.
       Used in package \code{xegaSelectGene} function
\code{ThresholdScaleFitness}.}

\item{scalingExp}{Scaling exponent \code{k} in \code{fit^k}.
       With "ConstantScaling": 0 =< k. 
       With "ThresholdScaling": 1 < k. (Default: 1)
       Used in package \code{xegaSelectGene}, functions
\code{ScalingFitness},
\code{ThresholdScaleFitness}.}

\item{scalingExp2}{Scaling exponent 
       for "ThresholdScaling": 0 <= k <1. (Default:1)
       Used in package \code{xegaSelectGene} function
\code{ThresholdScaleFitness}.}

\item{rdmWeight}{Numerical constant. Default: 1.0. Weight of 
       ratio of dispersion measures in continuous scaling.
       Used in package \code{xegaSelectGene} function
\code{ContinuousScaleFitness}.}

\item{drMax}{Maximal allowable dispersion ratio. Default: 2.0.
       Used in package \code{xegaSelectGene} function
\code{DispersionRatio}.}

\item{drMin}{Minimal allowable dispersion ratio. Default: 0.5.
       Used in package \code{xegaSelectGene} function
\code{DispersionRatio}.}

\item{dispersionMeasure}{Dispersion measure used for computation of the
ratio of dispersion measures for dynamic scaling methods.
Default: "var".
Available dispersion measures: 
"var, "std", "mad", "cv", "range", "iqr".
Argument of function factory 
\code{DispersionMeasureFactory} in package \code{xegaSelectGene}.}

\item{scalingDelay}{The ratio of dispersion measures compares the current
        population dispersion at t with the population dispersion 
        at t-scalingdelay. Default: 1.
       Used in package \code{xegaSelectGene} function
\code{DispersionRatio}.}

\item{accept}{Acceptance rule for new gene. Default: "All".
\itemize{
  \item "All"  function \code{AcceptNewGene} 
  \item "Best"  function \code{AcceptBest} 
  \item "Metropolis" function \code{AcceptMetropolis}.
        The behavior of this acceptance rule depends on:
        \enumerate{
        \item The distance between the fitness values.
              The larger the distance the larger the drop 
              in acceptance probability.
        \item \code{alpha} is \code{1} minus the discount rate of the cooling
              schedule. \code{alpha} is in \code{[0, 1]}.
              The smaller \code{alpha} the faster the drop 
              in temperatur and thus acceptance probability.
        \item \code{beta} a constant. The larger \code{beta}
              the faster the drop in acceptance probability.
        \item \code{temperature} the starting value of the 
              temperature. Must be higher than the number of 
              generations.
        }
  \item "IVMetropolis" function \code{AcceptIVMetropolis}.
        The behavior of this acceptance rule is qualitatively the same as that 
        of the Metropolis acceptance rule above.
        The acceptance rule is adaptive by a correction of the temperature
        in proportion to the difference between the fitness of the current best and
        the fitness of the gene considered.
        }
            Argument of function factory 
            \code{AcceptFactory} in package \code{xegaPopulation}.}

\item{alpha}{\code{1} minus the  discount rate for temperature. (Default: 0.99).
(Used in cooling schedule at the end of main GA-loop.)}

\item{beta}{Constant in Metropolis acceptance rule. (Default: 2.0).
(Used in Metroplis acceptance rule.)}

\item{cooling}{Cooling schedule for temperature. (Default: "ExponentialMultiplicative")
\itemize{
\item "ExponentialMultiplicative" calls \code{ExponentialMultiplicativeCooling}
\item "LogarithmicMultiplicative" calls \code{LogarithmicMultiplicativeCooling}
\item "PowerMultiplicative" calls \code{PowerMultiplicativeCooling}
\item "PowerAdditive" calls \code{PowerAdditiveCooling}
\item "ExponentialAdditive" calls \code{ExponentialAdditiveCooling}
\item "TrigonometricAdditive" calls \code{TrigonometricAdditiveCooling}
}
   Argument of function factory 
   \code{CoolingFactory} in package \code{xegaPopulation}.}

\item{coolingPower}{Exponent for PowerMultiplicative cooling schedule. 
(Default: 1. This is called linear multiplicative cooling.)}

\item{temp0}{Starting value of temperature (Default: 40).
(Used in Metroplis acceptance rule. Updated in cooling schedule.)}

\item{tempN}{Final value of temperature (Default: 0.01).
(Used in Metroplis acceptance rule. Updated in cooling schedule.)}

\item{verbose}{The value of \code{verbose} (Default: 1) controls the
             information displayed:
             \enumerate{
             \item \code{== 0}: Nothing is displayed.

             \item \code{== 1}: 1 point per generation.

             \item \code{> 1}: Max(fit), number of solutions, indices.

             \item \code{> 2}: and population fitness statistics.

             \item \code{> 3}: and fitness, value of phenotype, 
                                 and phenotype.
             \item \code{> 4}: and str(genotype). 
             }}

\item{logevals}{Boolean.
If \code{TRUE} then log all evaluations and their parameters 
in the file
\code{xegaEvalLog<time stamp>.rds}. Default: FALSE.

\code{log<-readRDS(xegaEvalLog<time stamp>.rds)} reads the log.
The format of a row of \code{log} is <fitness> <parameters>.}

\item{allsolutions}{Boolean. If \code{TRUE}, then return all best solutions.
Default: \code{FALSE}.}

\item{early}{Boolean. If FALSE (Default), ignore code for 
early termination. 
See \link{Parabola2DEarly}.}

\item{terminationEps}{Fraction of known optimal solution
   for computing termination interval. Default: 0.01
See \link{Parabola2DEarly}.}

\item{cores}{Number of cores used for multi core parallel execution.
(Default: NA. NA means that the number of cores 
is set by \code{parallelly:availableCores()} 
if the execution model is "MultiCore".}

\item{executionModel}{Execution model of fitness function evaluation.
Available:
\itemize{
\item "Sequential": \code{base::lapply} is used.
\item "MultiCore":  \code{parallel::mclapply} is used.
\item "FutureApply":  
      \code{future.apply::future_lapply} is used.
\item "Cluster":  Requires a proper configuration of the cluster.
 }
Default: "Sequential".}

\item{uParApply}{A user defined parallel apply function
(e.g. for Rmpi). If specified, overrides 
settings for \code{executionModel}. 
Default: \code{NULL}.}

\item{Cluster}{A cluster object generated by 
\code{parallel::makeCluster()} or
\code{parallelly::makeCluster()}.
Default: \code{NULL}.}

\item{profile}{Boolean. 
If \code{TRUE} measures execution time and counts number of executions
to main components of genetic algorithms. Default: \code{FALSE}.}

\item{batch}{Boolean.
If \code{TRUE} then save result in file
\code{xegaResult<time stamp>.rds}. Default: FALSE}

\item{path}{Path. Default: \code{""}.}
}
\value{
Result object. A named list of 
        \enumerate{
        \item
        \code{$popStat}: A matrix with mean, min, Q1, median, Q3, max,
                        variance, and median absolute deviation
                         of population fitness as columns:
                         i-th row for the measures of the i-th generation.
        \item 
        \code{$fit}: Fitness vector if \code{generations<=1} else: NULL.
        \item
        \code{$solution}: Named list with fields 
        \itemize{
        \item
        \code{$solution$name}:    Name of problem environment. 
        \item
        \code{$solution$fitness}: Fitness value of the best solution.
        \item
        \code{$solution$value}:   The evaluated best gene.
        \item
        \code{$solution$numberofsolutions}: 
                   Number of solutions with the same fitness. 
        \item
        \code{$solution$genotype}:     The gene a genetic code. 
        \item
        \code{$solution$phenotype}:    The decoded gene.
        \item
        \code{$solution$phenotypeValue}:   The   value of the
                         function of the parameters of the solution.
        \item 
        \code{$solution$evalFail}: Number of failures or fitness evaluations
        \item
        and, if configured, 
        \code{$solution$allgenotypes}, as well as 
        \code{$solution$allphenotypes}.
        }
        \item
        \code{$GAconfig}: For rerun with \code{xegaReRun()}.
        \item
        \code{$GAenv}: Attribute value list of GAconfig.
        \item \code{$timer}: An attribute value list with 
              the time used (in seconds) in the main blocks of the GA:
              tUsed, tInit, tNext, tEval, tObserve, and tSummary.
        }
}
\description{
\code{Run} runs an evolutionary or genetic algorithm 
       whose type is selected by \code{algorithm}. Available
       algorithms are:
       \enumerate{
       \item \code{"sga"}:    Genetic algorithm with binary genes.
       \item \code{"sgde"}:   Differential evolution with real genes.
       \item \code{"sgperm"}: Genetic algorithm with permutation genes. 
       \item \code{"sgp"}:    Grammar-based genetic programming with 
                              derivation-tree genes.
       \item \code{"sge"}:    Grammatical evolution (genetic algorithm 
                              with binary genes and a grammar-driven
                              decoder.
       }
  
      The choice of the algorithm determines the gene-dependent 
      configuration options.
}
\details{
The algorithm expects a problem environment \code{penv} which is a 
          named list with at least the following functions:
        \itemize{
     \item \code{$name()}:      The name of the problem environment.
     \item \code{$f(parm, gene=0, lF=0)}:   The function to optimize.
                                 The parameters gene and lF are provided
                                 for future extensions.
        }
  
     Additional parameters needed depend on the algorithm 
     and the problem environment. 
     For example, for binary genes for function optimization,    
     additional elements must be provided:

        \itemize{
     \item \code{$bitlength()}: The vector of the 
                                bitlengths of the parameters.  
     \item \code{$genelength()}: The number of bits of a gene.  
     \item \code{$lb()}:         The vector of lower bounds 
                                of the parameters. 
     \item \code{$ub()}:  The vector of upper bounds of the parameters. 
         }
}
\section{Problem Specification}{


The problem specification consists of 
\itemize{ 
\item \code{penv}: The problem environment. 
\item \code{max}:  Maximize? Boolean. Default: \code{TRUE}.
\item \code{grammar}: A grammar object. For the algorithms \code{"sgp"} and \code{"sge"}.   
}
}

\section{Basic Parameters}{


The main parameters of a ``standard'' genetic algorithm are:
   \itemize{
     \item \code{popsize}:     Population size.
     \item \code{generations}: Number of generations.
     \item \code{crossrate}:   Constant probability of one-point crossover.
     \item \code{mutrate}:     Constant probability of mutation.
         }

 \code{crossrate} and \code{mutrate} specify the probability of 
 applying the genetic operators crossover and mutation to a gene.

Two more parameters are important:

\itemize{
\item \code{elitist}: Boolean. If \code{TRUE} (default), the fittest gene always survives.
\item \code{replay}:  Integer. If \code{0} (default), a random seed of the random number generator is chosen.
                      For exact replications of a run of a genetic algorithm, set replay to a positive integer.
}
}

\section{Global and Local Parameters}{


However, when using uniform crossover instead of one-point crossover, 
an additional parameter which specifies the probability of taking a bit 
from the first parent becomes necessary. 
Therefore, we distinguish between global and local operator parameters:
\enumerate{
\item Global operator parameters: 
           The probabilities of applying a crossover (\code{crossrate}) or 
           a mutation operator (\code{mutrate}) to a gene.
\item Local operator parameters: 
      E.g. the per bit probability of mutation or the probability
      of taking a bit from parent 1 for the uniform crossover operator.
      Local operator parameters affect only 
      the genetic operator which needs them.
}

There exist several advantages of this classification of parameters:
\itemize{
\item For the formal analysis of the behavior of the algorithms, 
      we achieve a division in two parts: The equations of the 
      global parameters with operator specific expressions as plug-ins. 
\item For empirically finding parameterizations for problem classes, 
      we propose to fix local parameters at reasonable values
      (e.g. based on biological evidence) and 
      and conditional on this optimize the (few) remaining global 
      parameters.
\item For parallelization specialized 
gene processing pipelines can be built and more efficiently executed, 
because the global parameters \code{crossrate} and \code{mutrate} decide 
which genes survive 
\enumerate{
   \item unchanged, 
   \item mutated, 
   \item crossed, and 
   \item crossed as well as mutated. 
}}

To mimic a classic genetic algorithm with crossover and bit mutation rate, 
the probability of applying the mutation operator to a gene 
should be set to \code{1}.
}

\section{Global Adaptive Mechanisms}{


The adaptive mechanisms described in the following are based on threshold
rules which determine how a parameter of the genetic operator is adapted.
The threshold conditions are based on population statistics: 

\strong{Adaptive Scaling.} For adaptive scaling, select a dynamic scaling method,
                  e.g. \code{scaling="ThresholdScaling"}.
A high selection pressure decreases the dispersion in the population.
The parameter \code{scalingThreshold} is a numerical parameter which defines    
an interval from \code{1-scalingThreshold} to \code{1+scalingThreshold}:
\enumerate{
\item If the RDM is in this interval, the fitness function is not scaled. 
\item If the RDM is larger than the upper bound of the interval, 
      the constant \code{scalingExp} which is higher than \code{1} is chosen for the scaling function.
      This implements the rule: If the dispersion has increased, increase the selection pressure.  
\item If the RDM is smaller than the lower bound of the interval, 
      the constant \code{scalingExp2} which is smaller than \code{1} is chosen for the scaling function.
      This implements the rule: If the dispersion has decreased, increase the selection pressure.  
      }

 The dispersion measure is computed as ratio of the dispersion measure at \code{t} relative to the 
 dispersion measure at \code{t-scalingDelay}. 
 The default dispersion measure is the variance of the population fitness (\code{dispersionMeasure="var"}). 
 However, other dispersion measures ("std", "mad", "cv", "range", "iqr") can be configured.  

 Another adaptive scaling method is continuous scaling (\code{scaling="ContinuousScaling"}).
 The scaling exponent is adapted by a weighted ratio of dispersion measures. The weight 
 of the exponent is set by \code{rdmWeight=1.1}, its default is \code{1.0}. Since the ratio 
 of dispersion measures may be quite unstable, the default limits for the ratio are \code{drMin=0.5} 
 and \code{drMax=2.0}. 

\strong{Individually Variable Mutation and Crossover Probabilities}

The rationale of individually variable mutation and crossover rates is that selected genes 
with a low fitness should be changed by a genetic operator with a higher probability. 
This increases the chance of survival of the gene because of the chance of a fitness increase through  
crossover or mutation.

Select an adaptive genetic operator rate:
For the crossover rate, \code{ivcrossrate="IV"}. For the mutation rate, \code{ivmutrate="IV"}.

If the fitness of a gene is higher than \code{cutoffFit} times the current best fitness, 
the crossover rate is \code{crossrate} else the crossover rate is \code{crossrate2}.

If the fitness of a gene is higher than \code{cutoffFit} times the current best fitness, 
the mutation rate is \code{mutrate} else the mutation rate is \code{mutrate2}.
}

\section{The Initialization of a Population}{


For the algorithms "sga", "sgde", and "sgperm" the information needed for
initialization is the length of the gene in bits, in parameters, and in
the number of symbols of a permutation. 
For "sgp", the depth bound gives an upper limit for the 
program which can be represented by a derivation tree.
For "sge", a codon is an integer for selecting a production rule.
The number of bits of a genes is \code{codons*codonBits}. 

\tabular{lll}{
\strong{Algorithm}\tab \tab \strong{Parameters} \cr
\strong{"sga"}\tab Number of bits.  \tab \code{penv$genelength()} \cr
\strong{"sgde"}\tab Number of parameters. \tab 
                    \code{length(penv$bitlength()}, 
                    \code{penv$lb()}, \code{penv$ub()}\cr
\strong{"sgperm"}\tab Number of symbols. \tab \code{penv$genelength()} \cr
\strong{"sgp"}\tab Depth bound of derivation tree. \tab \code{maxdepth} \cr
\strong{"sge"}\tab Number of codons and 
   \tab\code{codons}, \code{codonBits},
                  \code{codonPrecision}, \code{maxPBias} \cr
\tab number of bits of a codon. \tab
}
}

\section{The Pipeline of Genetic Operators}{


The pipeline of genetic operators merges the pipeline of a genetic algorithm with the pipeline of 
evolutionary algorithms and simulated annealing by adding an acceptance step: 
\itemize{
\item For evolutionary algorithms,
the acceptance rule \code{accept="Best"} means that the fitter gene out of a parent and its kid survives
(is copied into the next generation).
\item For genetic algorithms the acceptance rule \code{accept="All"} means that always the kid survives.
\item For simulated annealing the acceptance rule \code{accept="Metropolis"} 
means that the survival probability of a kid with a fitness
worse than its parent decreases as the number of generations executed increases. 
}

Proper configuration of the pipeline allows the configuration of new algorithm variants which mix elements
of genetic, evolutionary, and simulated annealing algorithms.

The following table gives a working standard configuration of the pipeline of the genetic operators for each 
of the five algorithms:

\tabular{lccccc}{
\strong{Step/Algorithm}\tab\strong{"sga"}\tab\strong{"sgde"}\tab\strong{"sgperm"}\tab\strong{"sgp"}\tab\strong{"sge"}\cr 
(next) Scaling         \tab NoScaling    \tab NoScaling     \tab NoScaling       \tab NoScaling    \tab NoScaling    \cr
(next) Selection       \tab  SUS         \tab  UniformP     \tab SUS             \tab   SUS        \tab  SUS         \cr
(next) Replication     \tab  Kid2        \tab    DE         \tab   Kid2          \tab   Kid2       \tab  Kid2        \cr
(next) Crossover       \tab  Cross2Gene  \tab  UCrossGene   \tab  Cross2Gene     \tab Cross2Gene   \tab Cross2Gene   \cr
(next) Mutation        \tab  MutateGene  \tab  MutateGeneDE \tab  MutateGene     \tab MutateGene   \tab MutateGene   \cr
(next) Acceptance      \tab    All       \tab   Best        \tab   All           \tab    All       \tab   All        \cr 
(eval) Decoder         \tab   Bin2Dec    \tab Identity      \tab Identity        \tab     -        \tab   Mod        \cr
(eval) Evaluation      \tab  EvalGeneU   \tab EvalGeneU     \tab EvalGeneU       \tab  EvalGeneU   \tab EvalGeneU 
}
}

\section{Scaling}{


In genetic algorithms scaling of the fitness functions has the purpose of increasing or decreasing 
the selection pressure. Two classes of scaling methods are available:

\itemize{
\item Constant scaling methods.
\itemize{
\item No scaling (configured by \code{scaling="NoScaling"}).
\item Constant scaling (configured by \code{scaling="ConstantScaling"}).
      Depends on scaling exponent \code{scalingExp}. 
}
\item Adaptive scaling methods.
\itemize{      
\item Threshold scaling (configured by \code{scaling="ThresholdScaling"}).
      It is configured with the scaling exponents \code{scalingExp} and \code{scalingExp2}, 
      and the scaling threshold \code{scalingThreshold}.
      It uses a threshold rule about the change of a dispersion measure 
      of the population fitness \code{lF$RDM()} 
      to choose the scaling exponent:
      \itemize{
      \item \code{lF$RDM()>1+scalingThreshold}: The scaling exponent is \code{scalingExp} 
             which should be greater than \code{1}. 
            Rationale: Increase selection pressure to reduce dispersion of fitness.
      \item \code{lF$RDM()<1-scalingThreshold}: The scaling exponent is \code{scalingExp2} 
            which should be lower than \code{1}.
            Rationale: Decrease selection pressure to increase dispersion of fitness.
      \item Else: Scaling exponent is \code{1}. Fitness is not scaled.  
      }
\item Continuous scaling (configured by \code{scaling="ContinuousScaling"}).
        The ratio of the dispersion measures \code{lF$RDM()} is 
        greater than 1 if the dispersion increased in the last generation and 
        less than 1 if the dispersion decreased in the last generation. 
        The scaling exponent is the product of the ratio of the 
        dispersion measures \code{lF$RDM()} with the 
        weight \code{rdmWeight}. 
}
}

The change of the dispersion measure of the population fitness is measured by the function \code{lF$RDM()}
(RDM means (R)atio of (D)ispersion (M)easure). This function depends on
\itemize{
\item the choice of a dispersion measure of the population fitness \code{dispersionMeasure}. 
      The variance is the default (\code{dispersionMeasure="var"}).
      The following dispersion measure of the population fitness are avalaible:
      Variance (\code{"var"}), 
      standard deviation (\code{"std"}), 
      median absolute deviation (\code{"mad"}), 
      coefficient of variation (\code{"cv"}), 
      range (\code{"range"}), 
      inter quartile range (\code{"iqr"}). 
\item the scaling delay \code{scalingDelay}. The default is \code{scalingDelay=1}. 
      This means the ratio of the variance of the fitness of the population at time t 
      and the variance of the fitness of the population at time t-1 is computed.
\item the upper and lower bounds of the ratio of dispersion measures. 
\item Dispersion ratios may have extreme fluctuations: The parameters \code{drMax} and \code{drMin}  
      define upper and lower bounds of the ratio of dispersion measures. 
      The defaults are \code{drMax=2} and \code{drMin=1}.
}
See package \code{xegaSelectGene} <https://CRAN.R-project.org/package=xegaSelectGene>
}

\section{Selection}{


Selection operators determine which genes are chosen for the replication process for the next generation.
Selection operators are configured by \code{selection} and \code{mateselection} 
(the 2nd parent for crossover). The default operator is stochastic universal selection 
for both parents (configured by \code{selection="SUS"} and \code{mateselection="SUS"}).  
The following operators are implemented:
\itemize{
\item Uniform random selection with replacement (configured by \code{"Uniform"}).
      Needed for simulating uniform random mating behavior, computer experiments without
      selection pressure, for computing random search solutions as naive benchmarks.
\item Uniform random selection without replacement (configured by \code{"UniformP"}).
      Needed for differential evolution.
\item Selection proportional to fitness 
(in \code{O(n)} by \code{"SelectPropFit"}, in \code{O(n*log(n))} by \code{"SelectPropFitOnln"}, 
and in \code{O(n^2)} by \code{"SelectPropFitM"}).  
\code{offset} configures the shift of the fitness vector if \code{min(fit)=<0}.
\item Selection proportional to fitness differences
(in \code{O(n)} by \code{"SelectPropFitDiff"}, in \code{O(n*log(n))} by \code{"SelectPropFitDiffOnln"}, 
and in \code{O(n^2)} by \code{"SelectPropFitDiffM"}). 
Even the worst gene should have a minimal chance of survival: \code{eps} is added to the 
fitness difference vector. This also guarantees numerical stability for populations 
in which all genes have the same fitness. 
\item Deterministic tournament selection of \code{k} genes (configured by \code{"Tournament"}).  
      The tournament size is configured by \code{tournamentSize}.
      Selection pressure increases with tournament size. 
      The worst \code{k-1} genes of a population never survive.
\item Deterministic tournament selection of \code{2} genes (configured by \code{"Duel"}).  
\item Stochastic tournament selection of \code{k} genes (configured by \code{"STournament"}).  
      The tournament size is configured by \code{tournamentSize}.
\item Linear rank selection with selective pressure (configured by \code{"LRSelective"}). 
      The selection bias which regulates the selection pressure 
      is configured by \code{selectionBias} 
      (should be between \code{1.0} (uniform selection) and \code{2.0}). 
\item Linear rank selection with interpolated target sampling rates (configured by \code{"LRTSR"}).
      The maximal target sampling rate is configured by \code{maxTSR} 
      (should be between \code{1} and \code{2}).
\item Stochastic universal sampling (configured by \code{"SUS"}).
}

If \code{selectionContinuation=TRUE} then selection functions are computed exactly once 
per generation. They are transformed into lookup-functions which deliver the index of selected genes by 
indexing a vector of integers.

See package \code{xegaSelectGene} <https://CRAN.R-project.org/package=xegaSelectGene>
}

\section{Replication}{


For genetic algorithms ("sga", "sgp", sgperm", and "sge") 
in the replication process of a gene the crossover operator may 
by configured to produce one new gene (\code{replication="Kid1"})  
or two new genes (\code{replication="Kid2"}). The first version  
looses genetic information in the crossover operation, whereas the second version 
retains the genetic material in the population.
There is a dependency between \code{replication} and \code{crossover}:
\code{"Kid2"} requires a crossover operator which produces two kids.
The replication method is configured by the function  
\code{xegaGaReplicationFactory()} of package \code{xegaGaGene}.

Note that only the function \code{xegaGaReplicateGene} of \code{xegaGaGene} 
(configured with \code{replication="Kid1"}) implements a genetic operator pipeline
with an acceptance rule. 

For differential evolution (algorithm "sgde"), \code{replication="DE"} 
must be configured.
The replication method for differential evolution is configured by the function  
\code{xegaDfReplicationFactory()} of package \code{xegaDfGene}.
It implements a configurable acceptance rule. For classic differential evolution, 
use \code{accept="Best"}.
}

\section{Crossover}{


The table below summarizes the available crossover operators of the current version.

\tabular{lllll}{
\strong{Algorithm:} \tab \strong{"sga"} and \strong{"sge"}  \tab \strong{Package:}   \tab  \strong{xegaGaGene}  \tab\cr
 Kids \tab Name  \tab Function \tab crossover=  \tab Influenced by\cr
 (2 kids)  \tab 1-Point              \tab  xegaGaCross2Gene()            \tab "Cross2Gene"   \tab \cr
           \tab Uniform              \tab  xegaGaUCross2Gene()           \tab "UCross2Gene"  \tab \cr
           \tab Parametrized Uniform \tab xegaGaUPCross2Gene()           \tab "UPCross2Gene" \tab ucrossSwap \cr
 (1 kid)   \tab 1-Point              \tab xegaGaCrossGene()              \tab "CrossGene"   \tab           \cr
           \tab Uniform              \tab xegaGaUCrossGene()             \tab "UCrossGene"  \tab      \cr
           \tab Parametrized Uniform \tab  xegaGaUPCrossGene()           \tab "UPCrossGene" \tab ucrossSwap  \cr
 \strong{Algorithm:}  \tab \strong{"sgde"} \tab \strong{Package:}    \tab \strong{xegaDfGene}  \tab \cr
 (1 kid)   \tab 1-Point              \tab  xegaDfCrossGene()             \tab "CrossGene"   \tab           \cr
           \tab Uniform              \tab  xegaDfCrossGene()             \tab "UCrossGene"  \tab      \cr
           \tab Parametrized Uniform \tab  xegaDfUPCrossGene()           \tab "UPCrossGene" \tab ucrossSwap  \cr
\strong{Algorithm:}  \tab \strong{"sgperm"} \tab \strong{Package:}    \tab \strong{xegaPermGene}   \tab \cr
 (2 kids)  \tab Position-Based       \tab  xegaPermCross2Gene()          \tab "Cross2Gene"   \tab \cr
 (1 kid)   \tab Position-Based       \tab  xegaPermCrossGene()           \tab "CrossGene"   \tab           \cr
\strong{Algorithm:}  \tab \strong{"sgp"} \tab \strong{Package:}    \tab \strong{xegaGpGene}    \tab \cr
 (2 kids)  \tab of Derivation Trees  \tab  xegaGpAllCross2Gene()       \tab "Cross2Gene" or \tab maxcrossdepth, \cr
           \tab                      \tab                              \tab "All2Cross2Gene" \tab maxdepth, \cr
           \tab                      \tab                              \tab                  \tab and maxtrials \cr
           \tab of Depth-Filtered    \tab  xegaGpFilterCross2Gene()    \tab "FilterCross2Gene" \tab maxcrossdepth,\cr
           \tab Derivation Trees     \tab                              \tab                    \tab mincrossdepth, \cr
           \tab                      \tab                              \tab                    \tab maxdepth, \cr
           \tab                      \tab                              \tab                    \tab and maxtrials \cr
 (1 kid)   \tab of Derivation Trees  \tab  xegaGpAllCrossGene()       \tab "CrossGene" \tab maxcrossdepth, \cr
           \tab                      \tab                              \tab            \tab maxdepth, \cr
           \tab                      \tab                              \tab            \tab and maxtrials \cr
           \tab of Depth-Filtered    \tab  xegaGpFilterCrossGene()    \tab "FilterCrossGene" \tab maxcrossdepth, \cr
           \tab Derivation Trees     \tab                              \tab                    \tab mincrossdepth, \cr
           \tab                      \tab                              \tab                    \tab maxdepth, \cr
           \tab                      \tab                              \tab                    \tab and maxtrials \cr
}
}

\section{Mutation}{


The table below summarizes the available mutation operators of the current version.

\tabular{llll}{
\strong{Algorithm:} \tab \strong{"sga"} and \strong{"sge"}  \tab \strong{Package:}   \tab  \strong{xegaGaGene} \cr
 Name  \tab Function \tab mutation=  \tab Influenced by\cr
 Bit Mutation         \tab  xegaGaMutateGene()            \tab "MutateGene"   \tab bitmutrate \cr
 Individually        \tab  xegaGaIVAdaptiveMutateGene()  \tab "IVM"  \tab bitmutrate,     \cr
 Variable Bit        \tab                                \tab        \tab bitmutrate2,     \cr
 Mutation            \tab                                \tab        \tab  and cutoffFit     \cr
 \strong{Algorithm:}  \tab \strong{"sgde"} \tab \strong{Package:}    \tab \strong{xegaDfGene} \cr
 Differential \tab  xegaDfMutateGeneDE()             \tab "MutateGene" or   \tab lF$ScaleFactor() \cr
 Evolution Mutation             \tab                                     \tab "MutateGeneDe"    \tab (Configurable)   \cr
\strong{Algorithm:} \tab \strong{"sgperm"} \tab \strong{Package:}    \tab \strong{xegaPermGene}\cr
 Generalized Order  \tab  xegaPermMutateGeneOrderBased()          \tab "MutateGene"             \tab bitmutrate \cr
 Based Mutation     \tab                                \tab "MutateGeneOrderBased"   \tab \cr
 k Inversion  \tab  xegaPermMutateGenekInversion()          \tab "MutateGenekInversion" \tab lambda \cr
 Mutation     \tab                                \tab          \tab \cr
 2-Opt Mutation \tab  xegaPermMutateGene2Opt()          \tab "MutateGene2Opt" \tab max2opt \cr
 k-Opt LK Mutation \tab  xegaPermMutateGenekOptLK()          \tab "MutateGenekOptLK" \tab max2opt \cr
 (Lin-Kernighan)     \tab                                \tab          \tab \cr
 Greedy Path  \tab  xegaPermMutateGeneGreedy()          \tab "MutateGeneGreedy" \tab lambda \cr
 Mutation     \tab                                \tab          \tab \cr
 Best Greedy Path  \tab  xegaPermMutateGeneBestGreedy()          \tab "MutateGeneBestGreedy" \tab lambda \cr
 Mutation     \tab                                \tab          \tab \cr
 Random Mutation  \tab  xegaPermMutateMix()          \tab "MutateGeneMix" \tab  \cr
 Operator     \tab                                \tab          \tab \cr
\strong{Algorithm:}  \tab \strong{"sgp"} \tab \strong{Package:}    \tab \strong{xegaGpGene} \cr
 Derivation Tree  \tab  xegaGpMutateAllGene()       \tab "MutateGene" or \tab maxmutdepth \cr
 Mutation         \tab                              \tab "MutateAllGene" \tab  \cr
 Filtered Derivation   \tab  xegaGpMutateGeneFilter()       \tab "MutateFilterGene" \tab maxmutdepth, \cr
 Tree Mutation         \tab                              \tab                 \tab  minmutinsertiondepth, \cr
                      \tab                              \tab                 \tab  and maxmutinsertiondepth \cr
}
}

\section{Acceptance}{


Acceptance rules are extensions of genetic and evolutionary algorithms 
which to the best of my knowledge have their origin in simulated annealing.  
An acceptance rule compares the fitness value of a modified gene with the 
fitness value of its parent and determines which of the two genes is passed
into the next population.

An acceptance rule is only executed as part of the genetic operator pipeline, if 
\code{replicate="Kid1"} or \code{replicate="DE"}.

Two classes of acceptance rules are provided: 
\itemize{
\item Simple acceptance rules.   
\itemize{
\item Accept the new gene unconditionally (configured by \code{accept="All"}).
      The new gene is always passed to the next population. 
      Choose the rule for configuring a classic genetic algorithm.
      (The default). 
\item Accept only best gene (configured by \code{accept="Best"}).
      This acceptance rule guarantees an increasing fitness curve over the run 
      of the algorithm. For example, classic differential evolution uses this acceptance rule.
}
\item Configurable acceptance rules. 
      The rules always accept a new gene with a fitness improvement. 
      They also accept a new gene with a lower fitness with a probability which depends 
      on the fitness difference of the old and the new gene 
      and a temperature parameter which is reduced over the algorithm 
      run by a configurable cooling schedule. 
\itemize{
\item The Metropolis acceptance rule (configured by \code{accept="Metropolis"}). 
      The larger the parameter \code{beta} is set, the faster the drop in acceptance probability. 
\item The individually adaptive Metropolis acceptance rule (configured by \code{accept="IVMetropolis"}). 
      The larger the parameter \code{beta} is set, the faster the drop in acceptance probability. 
      Individually adaptive means that the temperature is corrected. The correction (increase) of temperature 
      depends on the difference between the fitness of the currently known best solution and the 
      and the fitness of the new gene.
}
}

The cooling schedule updates the temperature parameter at the end of the main loop.
The following cooling schedules are available:
\itemize{ 
\item Exponential multiplicative cooling (configured by \code{cooling="ExponentialMultiplicative"}).
      Depends on the discount factor \code{alpha} 
      and the start temperature \code{temp0}.
\item Logarithmic multiplicative cooling (configured by \code{cooling="LogarithmicMultiplicative"}).
      Depends on the scaling factor \code{alpha} 
      and the start temperature \code{temp0}.
\item Power multiplicative cooling (configured by \code{cooling="PowerMultiplicative"}).
      Depends on the scaling factor \code{alpha}, 
      the cooling power exponent \code{coolingPower}, 
      and the start temperature \code{temp0}.
\item Power additive cooling (configured by \code{cooling="PowerAdditive"}).
      Depends on the number of generations \code{generations}, 
      the cooling power exponent \code{coolingPower}, 
      the start temperature \code{temp0}, and the final temperature \code{tempN}.
\item Exponential additive cooling (configured by \code{cooling="ExponentialAdditive"}).
      Depends on the number of generations \code{generations}, the 
      start temperature \code{temp0}, and the final temperature \code{tempN}.
\item Trigonometric additive cooling (configured by \code{cooling="TrigonometricAdditive"}).
      Depends on the number of generations \code{generations}, the 
      start temperature \code{temp0}, and the final temperature \code{tempN}.
}

See package \code{xegaPopulation} <https://CRAN.R-project.org/package=xegaPopulation>
}

\section{Decoder}{


Decoders are algorithm and task dependent. Their implementation often makes use of a gene map. 
The table below summarizes the available decoders 
and gene maps of the current version.

\tabular{lccc}{
Algorithm:          \tab\strong{"sga"}          \tab\strong{"sgde"}         \tab\strong{"sgperm"}     \cr 
In package:         \tab xegaGaGene             \tab xegaDfGene             \tab xegaPermGene         \cr
Decoder:            \tab xegaGaDecodeGene()     \tab xegaDfDecodeGene()     \tab xegaPermDecodeGene() \cr
Gene map factories: \tab xegaGaGeneMapFactory() \tab xegaDfGeneMapFactory() \tab (Not configurable)   \cr
Method              \tab "Bin2Dec"               \tab "Identity"             \tab                      \cr
Method              \tab "Gray2Dec"              \tab                        \tab                      \cr
Method              \tab "Identity"              \tab                        \tab                      \cr
Method              \tab "Permutation"           \tab                        \tab                      \cr
}

\tabular{lcc}{
Algorithm:          \tab \strong{"sgp"}     \tab\strong{"sge"}          \cr 
In package:         \tab xegaGpGene         \tab xegaGeGene             \cr
Decoder:            \tab xegaGpDecodeGene() \tab xegaGeDecodeGene()     \cr
Gene map factories: \tab (Not configurable) \tab xegaGeGeneMapFactory() \cr
Method              \tab                    \tab "Mod"                  \cr
Method              \tab                    \tab "Buck"                 \cr
}
}

\section{Evaluation}{


The method of evaluation of a gene is configured by
\code{evalmethod}: "EvalGeneU" means that the function is always executed,
"Deterministic" evaluates a gene only once, and "Stochastic" incrementally updates mean and 
variance of a stochastic function. 
If \code{reportEvalErrors==TRUE}, evaluation failures are reported. However, for grammatical  
evolution without gene repair this should be set to \code{FALSE}. 
See package \code{xegaSelectGene} <https://CRAN.R-project.org/package=xegaSelectGene>
}

\section{Distributed and Parallel Processing}{


The current scope of parallelization is the parallel evaluation of genes (the steps marked with (eval) in the 
genetic operator pipeline. This strategy is less efficient for differential evolution and permutation-based genetic
algorithms because of the embedding of repeated evaluations into genetic operators. 

In general, distributed and parallel processing requires a sequence of three steps:  
\enumerate{
\item Configure and start the distributed or parallel infrastructure.
\item Distribute processing and collect results. 
      In a evolutionary or genetic algorithm the architectural pattern used for implementation 
      coarse-grained parallelism by parallel evaluation of the fitness of the genes of a population
      is the master/worker pattern. In principle, the \code{lapply()}-function for evaluating a population 
      of genes is replaced by a parallel version. 
\item Stop the distributed or parallel infrastructure.
}

For evolutionary and genetic algorithm, the second step is controlled by two parameters, 
namely \code{executionModel} and \code{uParApply}:
\enumerate{
\item If \code{uParApply=NULL}, then \code{executionModel} provides four ways of evaluating the 
      fitness of a population of genes:
      \enumerate{
      \item \code{executionModel="Sequential"}: The apply function used is \code{base::lapply()}. (Default).
      \item \code{executionModel="MultiCore"}:  The apply function used is \code{parallel::mclapply()}.
            If the number of cores is not specied by \code{cores}, the number of available cores 
            is determined by \code{parallelly::availableCores()}. 
      \item \code{executionModel="FutureApply"}:  The apply function used is \code{future.apply::future_lapply()}.
            The parallel/distributed model depends on a proper \code{future::plan()} statement. 
      \item \code{executionModel="Cluster"}:  The apply function used is \code{parallel::parLapply()}.
            The information about the configuration of the computing cluster (master, port, list of workers)
            must be provided by \code{Cluster=cl} where 
            \code{cl<-parallel::makeClusterPSOCK( rep(localhost, 5))}
            generates the cluster object and starts the R processes (of 5 workers in the same machine).  
      }
\item Assume that a user-defined parallel apply function has been defined and called \code{UPARAPPLY}. 
      By setting \code{uParApply=UPARAPPLY}, the \code{lapply()} function used is \code{UPARAPPLY()}. 
      This overrides the specification by \code{executionModel}. For example,
      parallelization via the MPI interface can be achieved by providing a user-defined parallel 
      \code{lapply()} function which is implemented by a user-defined function whose function body 
      is the line \code{Rmpi::mpi.parLapply( pop, FUN=EvalGene, lF=lF)}.
}

See package \code{xegaPopulation}  <https://CRAN.R-project.org/package=xegaPopulation> 

\strong{Acknowledgment.}The author acknowledges support by the state of Baden-Wrttemberg through bwHPC.
}

\section{Reporting}{


\itemize{ 
 \item \code{verbose} controls the information reported on the screen. 
 If \code{verbose} is \code{1}, then one dot is printed per generation to the console.
 \item \code{reportEvalErrors=TRUE} reports the output of errors of fitness function evaluations 
       to the console. Grammatical evolution (algorithm "sge") routinely attempts to evaluate 
       incomplete derivation trees. This leads to an evaluation error of the fitness function. 
 \item \code{profile=TRUE} measures the time spent in executing the main blocks of the algorithm:
       \code{InitPopulation()}, \code{NextPopulation()}, \code{EvalPopulation()}, 
       \code{ObservePopulation()}, and \code{SummaryPopulation()}. The measurements are stored in the
       named list \code{$timer} of the result object of the algorithm. 
 \item \code{allSolutions=TRUE} collects all solutions with the same fitness value. 
       The lists of the genotypes and phenotypes of these solutions are stored 
       in \code{$solution$allgenotypes} and \code{$allphenotypes} of the result object of the algorithm.
 \item \code{batch=TRUE} writes the result object and \code{logevals=TRUE} writes a list of all evaluated genes
       to a \code{rds}-file in the current directory. \code{path} allows to write the \code{rds}-files  
       into another directory. The existence of the directory specified by \code{path} is not checked.
       \code{batch=TRUE} combined with \code{verbose=TRUE} should be used in batch environments on 
       HPC environments.
 }
}

\examples{
a<-xegaRun(penv=Parabola2D, generations=10, popsize=20, verbose=0)
b<-xegaRun(penv=Parabola2D, algorithm="sga", generations=10, max=FALSE, 
   verbose=1, replay=5, profile=TRUE)
c<-xegaRun(penv=Parabola2D, max=FALSE, algorithm="sgde", 
   popsize=20, generations=50, 
   mutation="MutateGeneDE", scalefactor="Uniform", crossover="UCrossGene", 
   genemap="Identity", replication="DE", 
   selection="UniformP", mateselection="UniformP", accept="Best")
envXOR<-NewEnvXOR()
BG<-compileBNF(booleanGrammar())
d<-xegaRun(penv=envXOR, grammar=BG, algorithm="sgp",  
   generations=5, popsize=20, verbose=0)
e<-xegaRun(penv=envXOR, grammar=BG, algorithm="sge", genemap="Mod",  
   generations=5, popsize=20, reportEvalErrors=FALSE, verbose=1)
f<-xegaRun(penv=lau15, max=FALSE, algorithm="sgperm", 
   genemap="Identity", mutation="MutateGeneMix")

}
\seealso{
Other Main Program: 
\code{\link{xegaReRun}()}
}
\concept{Main Program}
